## 必读

### 前端资源 & sql

1. 位于others文件夹下，前端端口号为80
2. kill.bat用于杀死全部nginx进程。因为有时会启动多个nginx进程，而`nginx -s stop`只能停止一个进程。

### application.yaml

1. 后端端口号为8080
2. 出于安全考虑，我没有上传application.yaml文件，您只需将application-template.yaml文件重命名为application.yaml并修改mysql和redis配置信息。

## 功能说明

### 短信登录

1. 首先基于session实现短信登录，浏览器的cookie中有一个JSESSIONID，用于唯一标识用户。
2. 因为多个后端服务器并不共享session，所以我使用了redis存储用户信息。
    - 使用String类型存储手机号和验证码；
    - 使用Hash类型存储用户信息，包括id，nickname，icon
3. 通过springboot的拦截器Interceptor实现了拦截未登录用户的请求和刷新redis中用户的过期时间。
    - 记得使用将拦截器配置进spring容器。`@Configuration`注解

### 缓存

1. 使用redis缓存shop信息 get /shop/{id}
2. 使用redis缓存shop列表 get /shop-type/list
3. 商铺数据的redis与sql双写一致。sql数据更新时，删除redis中的数据。redis第一次读取时，会给一个ttl。
4. 如果在根据id查询商户信息时，遇到缓存击穿的情况，就把空值缓存到redis中。
5. 利用逻辑过期解决缓存击穿。即不设置真正的ttl，而是加一个ttl字段，每次查询时判断是否过去，若过期，则获取锁，获得锁成功的线程去fork子线程刷新数据，fork完和获取锁失败的线程均返回旧数据。
6. 封装redis工具类。包括
    1. 将任意对象序列化成json存入redis
    2. 将任意对象序列化成json存入redis 并且携带逻辑过期时间
    3. 设置空值解决缓存穿透
    4. 逻辑过期解决缓存击穿

### 优惠券

1. Redis实现全局唯一id 1位符号位 31位时间戳 32位序列号 com.hmdp.utils.RedisIdWorker
2. 实现优惠券秒杀功能。
   1. 使用乐观锁原理。第一次查询库存，然后执行库存充足性检查、优惠券时效检查；如果检查通过，则执行减库存操作，减库存时要保证stock > 0，即乐观锁的第二次查询。注意第二次查询和减库存在一个语句完成，保证原子性。
   2. 为保证1人只能抢一次优惠券，查优惠券库存支持，要先查优惠券订单记录。记录数为0才能继续抢。防止高并发下，一个人抢多次，有几个线程同时查到记录数为0。对用户使用悲观锁，即使用synchronized锁住用户的id。
   3. 使用redis分布式锁即setnx锁住用户id来解决多台后端服务器synchronized失效问题，然后加一个ttl，防止拿到锁的线程挂掉。
   4. 用uuid做value前缀，在释放锁时要检查该锁是否是自己的，防止误删其他线程的锁。但是有可能先判断该锁是自己的，然后线程阻塞（jvm等原因），阻塞的时候锁过期了，然后另一个线程拿到锁，这时候第一个线程醒来，就会误删第二个线程的锁。
   5. 利用lua脚本将判断该锁是自己的和释放锁搞到一块，解决上述问题，防止误删其他线程的锁。
   6. 使用redisson实现分布式锁 

部署redis集群，3个master节点，借助redis的multiLock来解决主从一致性问题（指刚给主节点加锁，主节点就挂了，还没更新到从节点，从节点转为主节点，可以再次拿锁）。multilock的特点是，只要有一个redis节点在加锁了，其他节点即使不加，依然不能获取该锁。
   
秒杀优化：
1. 使用redis缓存优惠券库存，减少数据库访问。构造秒杀lua脚本，包含优惠券库存检验和一人一单检验，检验通过后减库存，并在redis中保存下单用户和单号。
2. 使用阻塞队列，由一个线程来异步处理sql完成下单并将订单写入数据。
3. 抛弃阻塞队列，使用redis的stream消息队列来完成异步处理sql

### 达人探店
1. 发布和查看探店笔记。发布笔记时要实现上传文件接口，文件存储在云服务oss上，返回文件url，存入数据库，多个文件用“，”隔开。发布探店笔记时，要讲笔记推送给粉丝，存入redis。
2. 查看探店笔记时，不仅查询笔记本身的内容，还要标记这个笔记是否被查看者点赞。
3. 点赞关系用sortedset存储，键是blog的id，值是用户id，分数是点赞时间。因为点赞关系很多，用sql存储，容易给sql干宕机。点赞数是sql中的tb_blog的一个字段。
4. 实现点赞排行榜功能，通过zset的时间戳拿到最先点赞的五个用户id，然后查sql，返回给前端。前端在blog详情的下方和评论区上方展示。

### 好友关注
1. 关注和取关关系不仅写入sql，还写入redis，redis中键时当前用户id，值是关注的用户id，存储结构是set。
2. 共同关注是使用set的交集操作，查询到共同关注的用户id后，再查询sql用户信息。
3. 基于feed流，用户发blog时，会把blog推送给他所有的粉丝，每一个粉丝仅在redis中维护一个sortedset，键是用户id，值是blogid，分数是blog的发布时间。
4. 实现滚动分页查询，粉丝在查询关注者动态的时候，会基于上一次查询的最后一条时间戳，查询比这个时间戳更早的数据，直到最后。第一次查询时，时间戳是当前时间。

### 附近商铺
1. 使用redis的geo数据结构，存储商铺的经纬度，键是商铺类型，value是店铺id，score是经纬度。
2. 根据类型查询商铺时，前端可能传入经纬度，只需要使用geo相关操作，可以得到附近商铺id。
3. 实现分页查询：在查到附近商铺id时，只截取前end个，然后跳过前start个，从start到end的这几个数据查sql，返回给前端。

### 签到和UV统计
1. 使用bitmap实现签到功能，键是prefix+年+月+用户id，值是bitmap，每一位代表一天，1代表签到，0代表未签到。
2. 实现当前连续签到天数统计
3. 使用hyperloglog实现UV统计，占用内存小，有一定误差。


## 开发过程中遇到的bug

1. 只能拦截/user/code /user/login但无法拦截其他配置请求。

``` java
registry.addInterceptor(new LoginInterceptor())
   .excludePathPatterns(
   "/user/code",
   "/user/login",
   "blog/hot",
   "update/**",
   "shop-type/**",
   "shop/**",
   "voucher/**"
   ).order(1);
```

原因居然是忘记加/了，震惊！